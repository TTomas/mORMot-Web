/// remote access to a mORMot server using SmartMobileStudio
// - retrieved from http://localhost:888/root/wrapper/Pas2JS-mORMotPas2JsClient/mORMotPas2JsClient.pas
// at 2024-03-25 21:09:23 using "Pas2JS-mORMotPas2JsClient.pas.mustache" template
unit mORMotPas2JsClient;

{
  WARNING:
    This unit has been generated by a mORMot 2.2.7267 server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) 2024 Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1.1 and later.
}

interface

uses
  SysUtils,

  //-- pas2js
  JS,
  Web,
  Types,
  //----------

  Web.mORMot.Types,
  Web.mORMot.Utils,
  Web.mORMot.OrmTypes,
  Web.mORMot.AuthTypes,
  Web.mORMot.RestTypes,
  Web.mORMot.Rest;


type // define some enumeration types, used below
  TSex = (cMale, cFemale);

type // define some record types, used as properties below
  TCat = record
    Name: RawUtf8;
    Sex: TSex;
    Birthday: TDateTime;
  end;

  TCatNested1 = record
      Name: RawUtf8;
      Sex: TSex;
      Birthday: TDateTime;
  end;

type // define some dynamic array types, used as properties below
  TCat3Array = array[0..2] of TCat;
  TCatDynArray = array of TCat;
  TCatsNested2 = array of TCat;

  TPeople = record
    FirstName: RawUtf8;
    LastName: RawUtf8;
    Sex: TSex;
    Birthday: TDateTime;
    Cat: TCat;
    CatNested: TCatNested1;
    Cat3: TCat3Array;
    Cats: TCatDynArray;
    CatsNested: TCatsNested2;
  end;


type




  TCalculatorAddOnSuccess = reference to procedure(Result: Integer);
  TCalculatorArrayValueOnSuccess = reference to procedure(Result: JSValue);
  TCalculatorCountArrayOnSuccess = reference to procedure(Result: Integer);
  TCalculatorSumArrayOnSuccess = reference to procedure(Result: Double);
  TCalculatorFullNameOnSuccess = reference to procedure(aFullName: RawUtf8; aSize: Integer);
  TCalculatorCatIsMaleOnSuccess = reference to procedure(Result: Boolean);
  TCalculatorGetCatOnSuccess = reference to procedure(Result: TCat);
  TCalculatorGetPeopleOnSuccess = reference to procedure(aPeople: TPeople; Result: Boolean);
  TCalculatorAddPeopleOnSuccess = reference to procedure(Result: Integer);
  TCalculatorAddCat2PeopleOnSuccess = reference to procedure(aPeople: TPeople; Result: Boolean);
  /// service accessible via http://localhost:888/root/Calculator
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceCalculator = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TRestClientURI); override;

    procedure Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
    function _Add(const n1: Integer; const n2: Integer): Integer;

    procedure ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
    function _ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;

    procedure CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
    function _CountArray(const jsn: RawUtf8): Integer;

    procedure SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
    function _SumArray(const jsn: RawUtf8): Double;

    procedure FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
    procedure _FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);

    procedure CatIsMale(const aCat: TCat; 
      onSuccess: TCalculatorCatIsMaleOnSuccess; onError: TRestEvent);
    function _CatIsMale(const aCat: TCat): Boolean;

    procedure GetCat(
      onSuccess: TCalculatorGetCatOnSuccess; onError: TRestEvent);
    function _GetCat(): TCat;

    procedure GetPeople(const aId: Integer; var aPeople: TPeople; 
      onSuccess: TCalculatorGetPeopleOnSuccess; onError: TRestEvent);
    function _GetPeople(const aId: Integer; var aPeople: TPeople): Boolean;

    procedure AddPeople(const aPeople: TPeople; 
      onSuccess: TCalculatorAddPeopleOnSuccess; onError: TRestEvent);
    function _AddPeople(const aPeople: TPeople): Integer;

    procedure AddCat2People(const aCat: TCat; var aPeople: TPeople; 
      onSuccess: TCalculatorAddCat2PeopleOnSuccess; onError: TRestEvent);
    function _AddCat2People(const aCat: TCat; var aPeople: TPeople): Boolean;
  end;


const
  /// the server port, corresponding to http://localhost:888
  SERVER_PORT = 888;
  /// the server model root name, corresponding to http://localhost:888/root
  SERVER_ROOT = 'root';


/// return the database Model corresponding to this server
function GetModel(aRoot: string=SERVER_ROOT): TOrmModel;

/// create a TRestClientHTTP instance and connect to the server
// - it will use by default port 888 over root 'root', corresponding
// to http://localhost:888/root
// - secure connection will be established via TRestServerAuthenticationDefault
// with the supplied credentials
// - request will be asynchronous, and trigger onSuccess or onError event
procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: Integer=SERVER_PORT; aServerRoot: string=SERVER_ROOT);

// publish some low-level helpers for variant conversion
// - used internally: you should not need those functions in your end-user code
function Variant2TSex(const _variant: JSValue): TSex;
function TSexToText(const value: TSex): string;
function Variant2TCat(const Value: JSValue): TCat;
function TCat2Variant(const Value: TCat): JSValue;
function Variant2TCatNested1(const Value: JSValue): TCatNested1;
function TCatNested12Variant(const Value: TCatNested1): JSValue;
function Variant2TPeople(const Value: JSValue): TPeople;
function TPeople2Variant(const Value: TPeople): JSValue;
function Variant2TCat3Array(const _variant: JSValue): TCat3Array;
function TCat3Array2Variant(const _array: TCat3Array): JSValue;
function Variant2TCatDynArray(const _variant: JSValue): TCatDynArray;
function TCatDynArray2Variant(const _array: TCatDynArray): JSValue;
function Variant2TCatsNested2(const _variant: JSValue): TCatsNested2;
function TCatsNested22Variant(const _array: TCatsNested2): JSValue;


implementation


{ Some helpers for enumerates types }

function Variant2TSex(const _variant: JSValue): TSex;
begin
  Result := TSex(_variant);
end;

function TSexToText(const value: TSex): string;
begin
  Result := toString(value);
end;


{ Some helpers for record types:
  due to potential obfuscation of generated JavaScript, we can't assume
  that the JSON used for transmission would match record fields naming }

function Variant2TCat(const Value: JSValue): TCat;
begin
  Result.Name := toRawUtf8(TJSObject(Value)['Name']);
  Result.Sex := Variant2TSex(TJSObject(Value)['Sex']);
  Result.Birthday := Iso8601ToDateTime(TJSObject(Value)['Birthday']);
end;

function TCat2Variant(const Value: TCat): JSValue;
var
  rec: TJSObject;
begin
  rec := TJSObject.new;
  rec['Name'] := Value.Name;
  rec['Sex'] := ord(Value.Sex);
  rec['Birthday'] := DateTimeToIso8601(Value.Birthday);
  Result := rec;
end;

function Variant2TCatNested1(const Value: JSValue): TCatNested1;
begin
  Result.Name := toRawUtf8(TJSObject(Value)['Name']);
  Result.Sex := Variant2TSex(TJSObject(Value)['Sex']);
  Result.Birthday := Iso8601ToDateTime(TJSObject(Value)['Birthday']);
end;

function TCatNested12Variant(const Value: TCatNested1): JSValue;
var
  rec: TJSObject;
begin
  rec := TJSObject.new;
  rec['Name'] := Value.Name;
  rec['Sex'] := ord(Value.Sex);
  rec['Birthday'] := DateTimeToIso8601(Value.Birthday);
  Result := rec;
end;

function Variant2TPeople(const Value: JSValue): TPeople;
begin
  Result.FirstName := toRawUtf8(TJSObject(Value)['FirstName']);
  Result.LastName := toRawUtf8(TJSObject(Value)['LastName']);
  Result.Sex := Variant2TSex(TJSObject(Value)['Sex']);
  Result.Birthday := Iso8601ToDateTime(TJSObject(Value)['Birthday']);
  Result.Cat := Variant2TCat(TJSObject(Value)['Cat']);
  Result.CatNested := Variant2TCatNested1(TJSObject(Value)['CatNested']);
  Result.Cat3 := Variant2TCat3Array(TJSObject(Value)['Cat3']);
  Result.Cats := Variant2TCatDynArray(TJSObject(Value)['Cats']);
  Result.CatsNested := Variant2TCatsNested2(TJSObject(Value)['CatsNested']);
end;

function TPeople2Variant(const Value: TPeople): JSValue;
var
  rec: TJSObject;
begin
  rec := TJSObject.new;
  rec['FirstName'] := Value.FirstName;
  rec['LastName'] := Value.LastName;
  rec['Sex'] := ord(Value.Sex);
  rec['Birthday'] := DateTimeToIso8601(Value.Birthday);
  rec['Cat'] := TCat2Variant(Value.Cat);
  rec['CatNested'] := TCatNested12Variant(Value.CatNested);
  rec['Cat3'] := TCat3Array2Variant(Value.Cat3);
  rec['Cats'] := TCatDynArray2Variant(Value.Cats);
  rec['CatsNested'] := TCatsNested22Variant(Value.CatsNested);
  Result := rec;
end;


{ Some helpers for dynamic array types }

function Variant2TCat3Array(const _variant: JSValue): TCat3Array;
var
  tmp: TCat;
  i: Integer;
begin
  if isArray(_variant) then
  begin
    for i := 0 to TJSArray(_variant).Length-1 do begin
      tmp := Variant2TCat(TJSArray(_variant)[i]);
      Result[i] := tmp;
    end;
  end;
end;

function TCat3Array2Variant(const _array: TCat3Array): JSValue;
var
  i: Integer;
begin
  Result := TJSArray.new;
  for i := 0 to High(_array) do
    TJSArray(Result).push(TCat2Variant(_array[i]));
end;

function Variant2TCatDynArray(const _variant: JSValue): TCatDynArray;
var
  tmp: TCat;
  i: Integer;
begin
  if isArray(_variant) then
  begin
    SetLength(Result, TJSArray(_variant).Length);
    for i := 0 to TJSArray(_variant).Length-1 do begin
      tmp := Variant2TCat(TJSArray(_variant)[i]);
      Result[i] := tmp;
    end;
  end;
end;

function TCatDynArray2Variant(const _array: TCatDynArray): JSValue;
var
  i: Integer;
begin
  Result := TJSArray.new;
  for i := 0 to High(_array) do
    TJSArray(Result).push(TCat2Variant(_array[i]));
end;

function Variant2TCatsNested2(const _variant: JSValue): TCatsNested2;
var
  tmp: TCat;
  i: Integer;
begin
  if isArray(_variant) then
  begin
    SetLength(Result, TJSArray(_variant).Length);
    for i := 0 to TJSArray(_variant).Length-1 do begin
      tmp := Variant2TCat(TJSArray(_variant)[i]);
      Result[i] := tmp;
    end;
  end;
end;

function TCatsNested22Variant(const _array: TCatsNested2): JSValue;
var
  i: Integer;
begin
  Result := TJSArray.new;
  for i := 0 to High(_array) do
    TJSArray(Result).push(TCat2Variant(_array[i]));
end;




function GetModel(aRoot: string): TOrmModel;
begin
  Result := TOrmModel.Create([TAuthGroup, TAuthUser], aRoot);
end;

procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: Integer; aServerRoot: string);
var
  client: TRestClientHTTP;
begin
  client := TRestClientHTTP.Create(aServerAddress, aServerPort,
    GetModel(aServerRoot), true); // aOwnModel=true
  client.Connect(
    procedure(Client: TRestClientURI)
    begin
      try
        if client.ServerTimeStamp=0 then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if not client.SetUser(TRestServerAuthenticationDefault, aUserName, aPassword) then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if Assigned(onSuccess) then
          onSuccess(client);
      except
        if Assigned(onError) then
          onError(client);
      end;
    end,
    onError);
end;


{ TServiceCalculator }

constructor TServiceCalculator.Create(aClient: TRestClientURI);
begin
  fServiceName := 'Calculator';
  fServiceURI := 'Calculator';
  fInstanceImplementation := sicShared;
  fContractExpected := 'A788874160C720E1';
  inherited Create(aClient);
end;

procedure TServiceCalculator.Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'Add', 1,
    [n1, n2],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._Add(const n1: Integer; const n2: Integer): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'Add', 1,
    [n1, n2]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'ArrayValue', 1,
    [arrJSON, ix],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(res[0]);
    end,
    onError);
end;

function TServiceCalculator._ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'ArrayValue', 1,
    [arrJSON, ix]);
  Result := res[0];
end;

procedure TServiceCalculator.CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'CountArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._CountArray(const jsn: RawUtf8): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'CountArray', 1,
    [jsn]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'SumArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toDouble(res[0]));
    end,
    onError);
end;

function TServiceCalculator._SumArray(const jsn: RawUtf8): Double;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'SumArray', 1,
    [jsn]);
  Result := toDouble(res[0]);
end;

procedure TServiceCalculator.FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toRawUtf8(res[0]),toInteger(res[1]));
    end,
    onError);
end;

procedure TServiceCalculator._FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize]);
  aFullName := toRawUtf8(res[0]);
  aSize := toInteger(res[1]);
end;

procedure TServiceCalculator.CatIsMale(const aCat: TCat; 
      onSuccess: TCalculatorCatIsMaleOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'CatIsMale', 1,
    [TCat2Variant(aCat)],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toBoolean(res[0]));
    end,
    onError);
end;

function TServiceCalculator._CatIsMale(const aCat: TCat): Boolean;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'CatIsMale', 1,
    [TCat2Variant(aCat)]);
  Result := toBoolean(res[0]);
end;

procedure TServiceCalculator.GetCat(
      onSuccess: TCalculatorGetCatOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'GetCat', 1,
    [],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(Variant2TCat(res[0]));
    end,
    onError);
end;

function TServiceCalculator._GetCat(): TCat;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'GetCat', 1,
    []);
  Result := Variant2TCat(res[0]);
end;

procedure TServiceCalculator.GetPeople(const aId: Integer; var aPeople: TPeople; 
      onSuccess: TCalculatorGetPeopleOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'GetPeople', 2,
    [aId, TPeople2Variant(aPeople)],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(Variant2TPeople(res[0]),toBoolean(res[1]));
    end,
    onError);
end;

function TServiceCalculator._GetPeople(const aId: Integer; var aPeople: TPeople): Boolean;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'GetPeople', 2,
    [aId, TPeople2Variant(aPeople)]);
  aPeople := Variant2TPeople(res[0]);
  Result := toBoolean(res[1]);
end;

procedure TServiceCalculator.AddPeople(const aPeople: TPeople; 
      onSuccess: TCalculatorAddPeopleOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'AddPeople', 1,
    [TPeople2Variant(aPeople)],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._AddPeople(const aPeople: TPeople): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'AddPeople', 1,
    [TPeople2Variant(aPeople)]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.AddCat2People(const aCat: TCat; var aPeople: TPeople; 
      onSuccess: TCalculatorAddCat2PeopleOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'AddCat2People', 2,
    [TCat2Variant(aCat), TPeople2Variant(aPeople)],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(Variant2TPeople(res[0]),toBoolean(res[1]));
    end,
    onError);
end;

function TServiceCalculator._AddCat2People(const aCat: TCat; var aPeople: TPeople): Boolean;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'AddCat2People', 2,
    [TCat2Variant(aCat), TPeople2Variant(aPeople)]);
  aPeople := Variant2TPeople(res[0]);
  Result := toBoolean(res[1]);
end;


end.
