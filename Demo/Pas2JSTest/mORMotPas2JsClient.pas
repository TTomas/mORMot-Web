/// remote access to a mORMot server using SmartMobileStudio
// - retrieved from http://localhost:888/root/wrapper/Pas2JS-mORMotPas2JsClient/mORMotPas2JsClient.pas
// at 2024-03-11 15:01:02 using "Pas2JS-mORMotPas2JsClient.pas.mustache" template
unit mORMotPas2JsClient;

{
  WARNING:
    This unit has been generated by a mORMot 2.2.7195 server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) 2024 Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1.1 and later.
}

interface

uses
  SysUtils,

  //-- pas2js
  JS,
  Web,
  Types,
  //----------

  Web.mORMot.Types,
  Web.mORMot.OrmTypes,
  Web.mORMot.AuthTypes,
  Web.mORMot.RestTypes,
  Web.mORMot.Rest;


type




  TCalculatorAddOnSuccess = reference to procedure(Result: Integer);
  TCalculatorArrayValueOnSuccess = reference to procedure(Result: JSValue);
  TCalculatorCountArrayOnSuccess = reference to procedure(Result: Integer);
  TCalculatorSumArrayOnSuccess = reference to procedure(Result: Double);
  TCalculatorFullNameOnSuccess = reference to procedure(aFullName: RawUtf8; aSize: Integer);
  /// service accessible via http://localhost:888/root/Calculator
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceCalculator = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TRestClientURI); override;

    procedure Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
    function _Add(const n1: Integer; const n2: Integer): Integer;

    procedure ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
    function _ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;

    procedure CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
    function _CountArray(const jsn: RawUtf8): Integer;

    procedure SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
    function _SumArray(const jsn: RawUtf8): Double;

    procedure FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
    procedure _FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);
  end;


const
  /// the server port, corresponding to http://localhost:888
  SERVER_PORT = 888;
  /// the server model root name, corresponding to http://localhost:888/root
  SERVER_ROOT = 'root';


/// return the database Model corresponding to this server
function GetModel(aRoot: string=SERVER_ROOT): TOrmModel;

/// create a TRestClientHTTP instance and connect to the server
// - it will use by default port 888 over root 'root', corresponding
// to http://localhost:888/root
// - secure connection will be established via TRestServerAuthenticationDefault
// with the supplied credentials
// - request will be asynchronous, and trigger onSuccess or onError event
procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: integer=SERVER_PORT; aServerRoot: string=SERVER_ROOT);


implementation





function GetModel(aRoot: string): TOrmModel;
begin
  result := TOrmModel.Create([TAuthGroup, TAuthUser], aRoot);
end;

procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: integer; aServerRoot: string);
var
  client: TRestClientHTTP;
begin
  client := TRestClientHTTP.Create(aServerAddress, aServerPort,
    GetModel(aServerRoot), true); // aOwnModel=true
  client.Connect(
    procedure(Client: TRestClientURI)
    begin
      try
        if client.ServerTimeStamp=0 then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if not client.SetUser(TRestServerAuthenticationDefault, aUserName, aPassword) then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if Assigned(onSuccess) then
          onSuccess(client);
      except
        if Assigned(onError) then
          onError(client);
      end;
    end,
    onError);
end;


{ TServiceCalculator }

constructor TServiceCalculator.Create(aClient: TRestClientURI);
begin
  fServiceName := 'Calculator';
  fServiceURI := 'Calculator';
  fInstanceImplementation := sicShared;
  fContractExpected := 'B6BC89711034AED2';
  inherited Create(aClient);
end;

procedure TServiceCalculator.Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'Add', 1,
    [n1, n2],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._Add(const n1: Integer; const n2: Integer): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'Add', 1,
    [n1, n2]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'ArrayValue', 1,
    [arrJSON, ix],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(res[0]);
    end,
    onError);
end;

function TServiceCalculator._ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'ArrayValue', 1,
    [arrJSON, ix]);
  Result := res[0];
end;

procedure TServiceCalculator.CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'CountArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._CountArray(const jsn: RawUtf8): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'CountArray', 1,
    [jsn]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'SumArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toDouble(res[0]));
    end,
    onError);
end;

function TServiceCalculator._SumArray(const jsn: RawUtf8): Double;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'SumArray', 1,
    [jsn]);
  Result := toDouble(res[0]);
end;

procedure TServiceCalculator.FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toRawUtf8(res[0]),toInteger(res[1]));
    end,
    onError);
end;

procedure TServiceCalculator._FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize]);
  aFullName := toRawUtf8(res[0]);
  aSize := toInteger(res[1]);
end;


end.
