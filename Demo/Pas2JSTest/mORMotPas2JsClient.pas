/// remote access to a mORMot server using SmartMobileStudio
// - retrieved from http://localhost:888/root/wrapper/Pas2JS-mORMotPas2JsClient/mORMotPas2JsClient.pas
// at 2024-03-11 21:06:31 using "Pas2JS-mORMotPas2JsClient.pas.mustache" template
unit mORMotPas2JsClient;

{
  WARNING:
    This unit has been generated by a mORMot 2.2.6792 server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) 2024 Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1.1 and later.
}

interface

uses
  SysUtils,

  //-- pas2js
  JS,
  Web,
  Types,
  //----------

  Web.mORMot.Types,
  Web.mORMot.OrmTypes,
  Web.mORMot.AuthTypes,
  Web.mORMot.RestTypes,
  Web.mORMot.Rest;


type // define some enumeration types, used below
  TSex = (cMale, cFemale);

type // define some record types, used as properties below
  TCat = record
    Name: RawUtf8;
    Sex: TSex;
    Birthday: TDateTime;
  end;

type




  TCalculatorAddOnSuccess = reference to procedure(Result: Integer);
  TCalculatorArrayValueOnSuccess = reference to procedure(Result: JSValue);
  TCalculatorCountArrayOnSuccess = reference to procedure(Result: Integer);
  TCalculatorSumArrayOnSuccess = reference to procedure(Result: Double);
  TCalculatorFullNameOnSuccess = reference to procedure(aFullName: RawUtf8; aSize: Integer);
  TCalculatorCatIsMaleOnSuccess = reference to procedure(Result: Boolean);
  TCalculatorGetCatOnSuccess = reference to procedure(Result: TCat);
  /// service accessible via http://localhost:888/root/Calculator
  // - this service will run in sicShared mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  TServiceCalculator = class(TServiceClientAbstract)
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TRestClientURI); override;

    procedure Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
    function _Add(const n1: Integer; const n2: Integer): Integer;

    procedure ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
    function _ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;

    procedure CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
    function _CountArray(const jsn: RawUtf8): Integer;

    procedure SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
    function _SumArray(const jsn: RawUtf8): Double;

    procedure FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
    procedure _FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);

    procedure CatIsMale(const aCat: TCat; 
      onSuccess: TCalculatorCatIsMaleOnSuccess; onError: TRestEvent);
    function _CatIsMale(const aCat: TCat): Boolean;

    procedure GetCat(
      onSuccess: TCalculatorGetCatOnSuccess; onError: TRestEvent);
    function _GetCat(): TCat;
  end;


const
  /// the server port, corresponding to http://localhost:888
  SERVER_PORT = 888;
  /// the server model root name, corresponding to http://localhost:888/root
  SERVER_ROOT = 'root';


/// return the database Model corresponding to this server
function GetModel(aRoot: string=SERVER_ROOT): TOrmModel;

/// create a TRestClientHTTP instance and connect to the server
// - it will use by default port 888 over root 'root', corresponding
// to http://localhost:888/root
// - secure connection will be established via TRestServerAuthenticationDefault
// with the supplied credentials
// - request will be asynchronous, and trigger onSuccess or onError event
procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: integer=SERVER_PORT; aServerRoot: string=SERVER_ROOT);

// publish some low-level helpers for variant conversion
// - used internally: you should not need those functions in your end-user code
function Variant2TSex(const _variant: JSValue): TSex;
function TSexToText(const value: TSex): string;
function Variant2TCat(const Value: JSValue): TCat;
function TCat2Variant(const Value: TCat): JSValue;


implementation


{ Some helpers for enumerates types }

function Variant2TSex(const _variant: JSValue): TSex;
begin
  Result := TSex(_variant);
end;

function TSexToText(const value: TSex): string;
begin
  Result := toString(value);
end;

{ Some helpers for record types:
  due to potential obfuscation of generated JavaScript, we can't assume
  that the JSON used for transmission would match record fields naming }

function Variant2TCat(const Value: JSValue): TCat;
begin
  Result.Name := toRawUtf8(TJSObject(Value)['Name']);
  Result.Sex := Variant2TSex(TJSObject(Value)['Sex']);
  Result.Birthday := Iso8601ToDateTime(TJSObject(Value)['Birthday']);
end;

function TCat2Variant(const Value: TCat): JSValue;
var
  rec: TJSObject;
begin
  rec := TJSObject.new;
  rec['Name'] := Value.Name;
  rec['Sex'] := ord(Value.Sex);
  rec['Birthday'] := DateTimeToIso8601(Value.Birthday);
  Result := rec;
end;




function GetModel(aRoot: string): TOrmModel;
begin
  Result := TOrmModel.Create([TAuthGroup, TAuthUser], aRoot);
end;

procedure GetClient(const aServerAddress, aUserName, aPassword: string;
  onSuccess, onError: TRestEvent;
  aServerPort: integer; aServerRoot: string);
var
  client: TRestClientHTTP;
begin
  client := TRestClientHTTP.Create(aServerAddress, aServerPort,
    GetModel(aServerRoot), true); // aOwnModel=true
  client.Connect(
    procedure(Client: TRestClientURI)
    begin
      try
        if client.ServerTimeStamp=0 then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if not client.SetUser(TRestServerAuthenticationDefault, aUserName, aPassword) then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
        if Assigned(onSuccess) then
          onSuccess(client);
      except
        if Assigned(onError) then
          onError(client);
      end;
    end,
    onError);
end;


{ TServiceCalculator }

constructor TServiceCalculator.Create(aClient: TRestClientURI);
begin
  fServiceName := 'Calculator';
  fServiceURI := 'Calculator';
  fInstanceImplementation := sicShared;
  fContractExpected := 'E382542CFBE1310C';
  inherited Create(aClient);
end;

procedure TServiceCalculator.Add(const n1: Integer; const n2: Integer; 
      onSuccess: TCalculatorAddOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'Add', 1,
    [n1, n2],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._Add(const n1: Integer; const n2: Integer): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'Add', 1,
    [n1, n2]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.ArrayValue(const arrJSON: RawUtf8; const ix: Integer; 
      onSuccess: TCalculatorArrayValueOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'ArrayValue', 1,
    [arrJSON, ix],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(res[0]);
    end,
    onError);
end;

function TServiceCalculator._ArrayValue(const arrJSON: RawUtf8; const ix: Integer): JSValue;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'ArrayValue', 1,
    [arrJSON, ix]);
  Result := res[0];
end;

procedure TServiceCalculator.CountArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorCountArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'CountArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toInteger(res[0]));
    end,
    onError);
end;

function TServiceCalculator._CountArray(const jsn: RawUtf8): Integer;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'CountArray', 1,
    [jsn]);
  Result := toInteger(res[0]);
end;

procedure TServiceCalculator.SumArray(const jsn: RawUtf8; 
      onSuccess: TCalculatorSumArrayOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'SumArray', 1,
    [jsn],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toDouble(res[0]));
    end,
    onError);
end;

function TServiceCalculator._SumArray(const jsn: RawUtf8): Double;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'SumArray', 1,
    [jsn]);
  Result := toDouble(res[0]);
end;

procedure TServiceCalculator.FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer; 
      onSuccess: TCalculatorFullNameOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toRawUtf8(res[0]),toInteger(res[1]));
    end,
    onError);
end;

procedure TServiceCalculator._FullName(const aFirstName: RawUtf8; const aLastName: RawUtf8; var aFullName: RawUtf8; var aSize: Integer);
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'FullName', 2,
    [aFirstName, aLastName, aFullName, aSize]);
  aFullName := toRawUtf8(res[0]);
  aSize := toInteger(res[1]);
end;

procedure TServiceCalculator.CatIsMale(const aCat: TCat; 
      onSuccess: TCalculatorCatIsMaleOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'CatIsMale', 1,
    [TCat2Variant(aCat)],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(toBoolean(res[0]));
    end,
    onError);
end;

function TServiceCalculator._CatIsMale(const aCat: TCat): Boolean;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'CatIsMale', 1,
    [TCat2Variant(aCat)]);
  Result := toBoolean(res[0]);
end;

procedure TServiceCalculator.GetCat(
      onSuccess: TCalculatorGetCatOnSuccess; onError: TRestEvent);
begin 
  fClient.CallRemoteServiceAsynch(self, 'GetCat', 1,
    [],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess(Variant2TCat(res[0]));
    end,
    onError);
end;

function TServiceCalculator._GetCat(): TCat;
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, 'GetCat', 1,
    []);
  Result := Variant2TCat(res[0]);
end;


end.
