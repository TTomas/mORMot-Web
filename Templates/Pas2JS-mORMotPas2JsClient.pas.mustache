/// remote access to a mORMot server using SmartMobileStudio
{{#uri}}
// - retrieved from {{protocol}}://{{host}}/{{uri}}
// at {{time}} using "{{templateName}}" template
{{/uri}}
{{^uri}}
// - generated at {{time}}
{{/uri}}
unit {{fileName}};

{
  WARNING:
    This unit has been generated by a mORMot {{mORMotVersion}} server.
    Any manual modification of this file may be lost after regeneration.

  Synopse mORMot framework. Copyright (C) {{year}} Arnaud Bouchez
    Synopse Informatique - http://synopse.info

  This unit is released under a MPL/GPL/LGPL tri-license,
  and therefore may be freely included in any application.

  This unit would work on Smart Mobile Studio 2.1.1 and later.
}

interface

uses
  SysUtils,

  //-- pas2js
  JS,
  Web,
  Types,
  //----------

  Web.mORMot.Types,
  Web.mORMot.OrmTypes,
  Web.mORMot.AuthTypes,
  Web.mORMot.RestTypes,
  Web.mORMot.Rest;

{{! recursive partials used to write records type definition}}
{{<writerec}}record
{{#fields}}
{{nestedIdentation}}    {{propName}}: {{#typeDelphi}}{{typeDelphi}};{{/typeDelphi}}{{#nestedSimpleArray}}array of {{typeDelphi}};{{/nestedSimpleArray}}
{{/fields}}{{/writerec}}
{{#withEnumerates}}
type // define some enumeration types, used below
{{#enumerates}}
  {{name}} = ({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/enumerates}}

{{/withEnumerates}}
{{#withSets}}
type // define some set types, used below
{{#sets}}
  {{name}} = set of({{#values}}{{.}}{{^-last}}, {{/-last}}{{/values}});
{{/sets}}

{{/withSets}}
{{#withRecords}}
type // define some record types, used as properties below
{{#records}}
  {{name}} = {{>writerec}}  end;

{{/records}}
{{/withRecords}}
{{#withArrays}}
type // define some dynamic array types, used as properties below
{{#arrays}}
  {{name}} = array{{#staticMaxIndex}}[0..{{staticMaxIndex}}]{{/staticMaxIndex}} of {{typeSource}};
{{/arrays}}

{{/withArrays}}
type
{{! recursive partial used for Async OnSuccess procedure}}
{{<methodAsynchOnSuccess}}T{{interfaceURI}}{{methodName}}OnSuccess{{/methodAsynchOnSuccess}}
{{<methodAsynch}}{{methodName}}({{#args}}{{#dirInput}}{{dirName}} {{argName}}: {{typeDelphi}}; {{/dirInput}}{{/args}}
      onSuccess: {{>methodAsynchOnSuccess}}; onError: TRestEvent);{{/methodAsynch}}
{{<methodSynch}}_{{methodName}}({{#args}}{{^dirResult}}{{dirName}} {{argName}}: {{typeDelphi}}{{commaArg}}{{/dirResult}}{{/args}}){{#args}}{{#dirResult}}: {{#isVariant}}JSValue{{/isVariant}}{{^isVariant}}{{typeDelphi}}{{/isVariant}}{{/dirResult}}{{/args}};{{/methodSynch}}
{{#soa}}{{#services}}{{#methods}}
  {{>methodAsynchOnSuccess}} = reference to procedure({{#args}}{{#dirOutput}}{{argName}}: {{#isVariant}}JSValue{{/isVariant}}{{^isVariant}}{{typeDelphi}}{{/isVariant}}{{commaOutResult}}{{/dirOutput}}{{/args}});{{/methods}}{{/services}}{{/soa}}
{{#orm}}
{{^isInMormotPas}}
  /// map "{{tableName}}" table
  {{className}} = class(TSQLRecord)
  protected
    {{#fields}}
    f{{name}}: {{typePascal}}; 
    {{/fields}}
    // those overridden methods will emulate the needed RTTI
    class function ComputeRTTI: TRTTIPropInfos; override;
    procedure SetProperty(FieldIndex: Integer; const Value: variant); override;
    function GetProperty(FieldIndex: Integer): variant; override;
  public
{{#fields}}
{{#isSQLRecord}}    // defined as {{name}}: {{typeDelphi}} on the server
{{/isSQLRecord}}
    property {{name}}: {{typePascal}} read f{{name}} write f{{name}};
{{/fields}}
  end;
  
{{/isInMormotPas}}
{{/orm}}
{{#soa.services}}
  /// service accessible {{#uri}}via {{protocol}}://{{host}}/{{root}}/{{uri}}{{/uri}}
  // - this service will run in sic{{instanceCreationName}} mode
  // - synchronous and asynchronous methods are available, depending on use case
  // - synchronous _*() methods will block the browser execution, so won't be
  // appropriate for long process - on error, they may raise EServiceException
  {{#isClientDriven}}
  // - you should call explicitly Free to release the server instance
  {{/isClientDriven}}
  TService{{interfaceURI}} = class(TServiceClientAbstract{{#isClientDriven}}ClientDriven{{/isClientDriven}})
  public
    /// will initialize an access to the remote service
    constructor Create(aClient: TRestClientURI); override;
{{#methods}}

    procedure {{>methodAsynch}}
    {{verb}} {{>methodSynch}}
{{/methods}}
  end;

{{/soa.services}}

const
  /// the server port{{#uri}}, corresponding to {{protocol}}://{{host}}{{/uri}}
  SERVER_PORT = {{port}};
  /// the server model root name{{#uri}}, corresponding to {{protocol}}://{{host}}/{{root}}{{/uri}}
  SERVER_ROOT = '{{root}}';


/// return the database Model corresponding to this server
function GetModel(aRoot: string=SERVER_ROOT): TOrmModel;

/// create a TRestClientHTTP instance and connect to the server
// - it will use by default port {{port}} over root '{{root}}'{{#host}}, corresponding
// to {{protocol}}://{{host}}/{{root}}{{/host}}
{{#authClass}}
// - secure connection will be established via {{.}}
// with the supplied credentials
{{/authClass}}
// - request will be asynchronous, and trigger onSuccess or onError event
procedure GetClient(const aServerAddress{{#authClass}}, aUserName, aPassword{{/authClass}}: string;
  onSuccess, onError: TRestEvent;
  aServerPort: Integer=SERVER_PORT; aServerRoot: string=SERVER_ROOT);

{{#withHelpers}}
// publish some low-level helpers for variant conversion
// - used internally: you should not need those functions in your end-user code
{{#enumerates}}
function Variant2{{name}}(const _variant: JSValue): {{name}};
function {{name}}ToText(const value: {{name}}): string;
{{/enumerates}}
{{#records}}
function Variant2{{name}}(const Value: JSValue): {{name}};
function {{name}}2Variant(const Value: {{name}}): JSValue;
{{/records}}
{{#arrays}}
function Variant2{{name}}(const _variant: JSValue): {{name}};
function {{name}}2Variant(const _array: {{name}}): JSValue;
{{/arrays}}

{{/withHelpers}}

implementation
{{<setrec}}{{#fields}}
{{#isSimple}}  Result.{{propName}} := {{#fromVariant}}{{fromVariant}}{{/fromVariant}}{{^fromVariant}}to{{typeDelphi}}{{/fromVariant}}(TJSObject(Value)['{{propName}}']);
{{/isSimple}}{{#fromVariant}}  Result.{{propName}} := {{fromVariant}}(TJSObject(Value)['{{propName}}']);
{{/fromVariant}}{{#nestedSimpleArray}}  if VariantType(Value.{{fullPropName}})=jvArray then
    for var i := 0 to Integer(Value.{{fullPropName}}.length)-1 do
      Result.{{fullPropName}}.Add({{typePascal}}(Value.{{fullPropName}}[i]));
{{/nestedSimpleArray}}{{/fields}}{{/setrec}}
{{<getrec}}{{#fields}}
{{#isSimple}}  rec['{{propName}}'] := Value.{{propName}};
{{/isSimple}}{{#toVariant}}  rec['{{propName}}'] := {{toVariant}}(Value.{{propName}});
{{/toVariant}}{{#nestedSimpleArray}}  Result.{{propName}} := variant(Value.{{propName}});
{{/nestedSimpleArray}}{{/fields}}{{/getrec}}
{{#withEnumerates}}
{ Some helpers for enumerates types }

{{#enumerates}}
function Variant2{{name}}(const _variant: JSValue): {{name}};
begin
  Result := {{name}}(_variant);
end;

function {{name}}ToText(const value: {{name}}): string;
begin
  Result := toString(value);
end;

{{/enumerates}}

{{/withEnumerates}}
{{#withRecords}}
{ Some helpers for record types:
  due to potential obfuscation of generated JavaScript, we can't assume
  that the JSON used for transmission would match record fields naming }
{{#records}}

function Variant2{{name}}(const Value: JSValue): {{name}};
begin
{{>setrec}}
end;

function {{name}}2Variant(const Value: {{name}}): JSValue;
var
  rec: TJSObject;
begin
  rec := TJSObject.new;
{{>getrec}}
  Result := rec;
end;
{{/records}}

{{/withRecords}}
{{#withArrays}}

{ Some helpers for dynamic array types }

{{#arrays}}
function Variant2{{name}}(const _variant: JSValue): {{name}};
var
  tmp: {{typeSource}};
  i: Integer;
begin
  if isArray(_variant) then
  begin{{^staticMaxIndex}}
    SetLength(Result, TJSArray(_variant).Length);{{/staticMaxIndex}}
    for i := 0 to TJSArray(_variant).Length-1 do begin
      tmp := {{#fromVariant}}{{fromVariant}}{{/fromVariant}}(TJSArray(_variant)[i]);
      Result[i] := tmp;
    end;
  end;
end;

function {{name}}2Variant(const _array: {{name}}): JSValue;
var
  i: Integer;
begin
  Result := TJSArray.new;
  for i := 0 to High(_array) do
    TJSArray(Result).push({{#toVariant}}{{toVariant}}{{/toVariant}}(_array[i]));
end;

{{/arrays}}
{{/withArrays}}
{{#orm}}

{{^isInMormotPas}}

{ {{className}} }

class function {{className}}.ComputeRTTI: TRTTIPropInfos;
begin
  Result := TRTTIPropInfos.Create(
    [{{#fields}}'{{name}}'{{comma}}{{/fields}}],
    [{{#fields}}{{typekindname}}{{comma}}{{/fields}}]);
end;

procedure {{className}}.SetProperty(FieldIndex: Integer; const Value: variant);
begin
  case FieldIndex of
  0: fID := Value;
  {{#fields}}
  {{index}}: f{{name}} := {{#fromVariant}}{{fromVariant}}({{/fromVariant}}Value{{#fromVariant}}){{/fromVariant}};
  {{/fields}}
  end;
end;

function {{className}}.GetProperty(FieldIndex: Integer): variant;
begin
  case FieldIndex of
  0: Result := fID;
  {{#fields}}
  {{index}}: Result := {{#toVariant}}{{toVariant}}({{/toVariant}}f{{name}}{{#toVariant}}){{/toVariant}};
  {{/fields}}
  end;
end;

{{/isInMormotPas}}
{{/orm}}

function GetModel(aRoot: string): TOrmModel;
begin
  Result := TOrmModel.Create([{{#orm}}{{className}}{{comma}}{{#comma}} {{/comma}}{{/orm}}], aRoot);
end;

procedure GetClient(const aServerAddress{{#authClass}}, aUserName, aPassword{{/authClass}}: string;
  onSuccess, onError: TRestEvent;
  aServerPort: Integer; aServerRoot: string);
var
  client: TRestClientHTTP;
begin
  client := TRestClientHTTP.Create(aServerAddress, aServerPort,
    GetModel(aServerRoot), true); // aOwnModel=true
  client.Connect(
    procedure(Client: TRestClientURI)
    begin
      try
        if client.ServerTimeStamp=0 then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
{{#authClass}}
        if not client.SetUser({{.}}, aUserName, aPassword) then begin
          if Assigned(onError) then
            onError(client);
          exit;
        end;
{{/authClass}}
        if Assigned(onSuccess) then
          onSuccess(client);
      except
        if Assigned(onError) then
          onError(client);
      end;
    end,
    onError);
end;

{{#soa.services}}

{ TService{{interfaceURI}} }

constructor TService{{interfaceURI}}.Create(aClient: TRestClientURI);
begin
  fServiceName := '{{interfaceURI}}';
  fServiceURI := '{{uri}}';
  fInstanceImplementation := sic{{instanceCreationName}};
  fContractExpected := '{{contractExpected}}';
  inherited Create(aClient);
end;

{{#methods}}
procedure TService{{interfaceURI}}.{{>methodAsynch}}
begin 
  fClient.CallRemoteServiceAsynch(self, '{{methodName}}', {{ArgsOutputCount}},
    [{{#args}}{{#dirInput}}{{#toVariant}}{{toVariant}}({{argName}}){{/toVariant}}{{^toVariant}}{{argName}}{{/toVariant}}{{#commaInSingle}}{{commaInSingle}} {{/commaInSingle}}{{/dirInput}}{{/args}}],
    procedure(res: TJSValueDynArray)
    begin
      onSuccess({{#args}}{{#dirOutput}}{{#fromVariant}}{{fromVariant}}({{/fromVariant}}{{^isVariant}}{{^fromVariant}}to{{typeDelphi}}({{/fromVariant}}{{/isVariant}}res[{{indexOutResult}}{{^isVariant}}{{^fromVariant}}){{/fromVariant}}{{/isVariant}}{{#fromVariant}}){{/fromVariant}}{{#commaOutResult}},{{/commaOutResult}}{{/dirOutput}}{{/args}});
    end,
    onError{{#resultIsServiceCustomAnswer}}, true{{/resultIsServiceCustomAnswer}});
end;

{{verb}} TService{{interfaceURI}}.{{>methodSynch}}
var
  res: TJSValueDynArray;
begin
  res := fClient.CallRemoteServiceSynch(self, '{{methodName}}', {{ArgsOutputCount}},
    [{{#args}}{{#dirInput}}{{#toVariant}}{{toVariant}}({{argName}}){{/toVariant}}{{^toVariant}}{{argName}}{{/toVariant}}{{#commaInSingle}}{{commaInSingle}} {{/commaInSingle}}{{/dirInput}}{{/args}}]{{#resultIsServiceCustomAnswer}},true{{/resultIsServiceCustomAnswer}});
{{#args}}{{#dirOutput}}  {{argName}} := {{#fromVariant}}{{fromVariant}}({{/fromVariant}}{{^isVariant}}{{^fromVariant}}to{{typeDelphi}}({{/fromVariant}}{{/isVariant}}res[{{indexOutResult}}{{^isVariant}}{{^fromVariant}}){{/fromVariant}}{{/isVariant}}{{#fromVariant}}){{/fromVariant}};
{{/dirOutput}}{{/args}}end;

{{/methods}}
{{/soa.services}}

end.
